<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Autonomous ShaPe EstimatioN (ASPEN): Adjacency_List&lt; T1, T2 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Autonomous ShaPe EstimatioN (ASPEN)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_adjacency___list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Adjacency_List&lt; T1, T2 &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_adjacency___list.html" title="Adjacency_List class template. This is a template for a graph of vertices and edges of types T1 and T...">Adjacency_List</a> class template. This is a template for a graph of vertices and edges of types T1 and T2, respectively.  
 <a href="class_adjacency___list.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex type definition for the <a class="el" href="class_adjacency___list.html" title="Adjacency_List class template. This is a template for a graph of vertices and edges of types T1 and T...">Adjacency_List</a> graph class.  <a href="struct_adjacency___list_1_1vertex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a36f797555285f40b0320eb745774e127"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_adjacency___list_1_1vertex.html">Adjacency_List::vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a36f797555285f40b0320eb745774e127">vertex_type</a></td></tr>
<tr class="memdesc:a36f797555285f40b0320eb745774e127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex type definition for the <a class="el" href="class_adjacency___list.html" title="Adjacency_List class template. This is a template for a graph of vertices and edges of types T1 and T...">Adjacency_List</a> graph class.  <a href="#a36f797555285f40b0320eb745774e127">More...</a><br /></td></tr>
<tr class="separator:a36f797555285f40b0320eb745774e127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d0ad868f211a253fc7f5fc09f29b65"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; T2, <a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#ad2d0ad868f211a253fc7f5fc09f29b65">edge</a></td></tr>
<tr class="memdesc:ad2d0ad868f211a253fc7f5fc09f29b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">edge type definition:  <a href="#ad2d0ad868f211a253fc7f5fc09f29b65">More...</a><br /></td></tr>
<tr class="separator:ad2d0ad868f211a253fc7f5fc09f29b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1ff6746e887afb9fd3eb33f0692e84"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; T1, <a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a5f1ff6746e887afb9fd3eb33f0692e84">vertexmap</a></td></tr>
<tr class="memdesc:a5f1ff6746e887afb9fd3eb33f0692e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertexmap type definition:  <a href="#a5f1ff6746e887afb9fd3eb33f0692e84">More...</a><br /></td></tr>
<tr class="separator:a5f1ff6746e887afb9fd3eb33f0692e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a730c002bfea9ee4745be4b11e5ca10db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a730c002bfea9ee4745be4b11e5ca10db">Adjacency_List</a> ()</td></tr>
<tr class="memdesc:a730c002bfea9ee4745be4b11e5ca10db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a730c002bfea9ee4745be4b11e5ca10db">More...</a><br /></td></tr>
<tr class="separator:a730c002bfea9ee4745be4b11e5ca10db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e980e39f44ca8bfa305e0b009b72200"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e980e39f44ca8bfa305e0b009b72200"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a1e980e39f44ca8bfa305e0b009b72200">~Adjacency_List</a> ()</td></tr>
<tr class="memdesc:a1e980e39f44ca8bfa305e0b009b72200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a1e980e39f44ca8bfa305e0b009b72200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9a43d2d171801e35c1f45ae6baca93"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#afc9a43d2d171801e35c1f45ae6baca93">getnumv</a> ()</td></tr>
<tr class="memdesc:afc9a43d2d171801e35c1f45ae6baca93"><td class="mdescLeft">&#160;</td><td class="mdescRight">uint16_t <a class="el" href="class_adjacency___list.html#afc9a43d2d171801e35c1f45ae6baca93" title="uint16_t getnumv() ">getnumv()</a>  <a href="#afc9a43d2d171801e35c1f45ae6baca93">More...</a><br /></td></tr>
<tr class="separator:afc9a43d2d171801e35c1f45ae6baca93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2da43c411ed0a239798a2a3c883f24"><td class="memItemLeft" align="right" valign="top">T2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#aeb2da43c411ed0a239798a2a3c883f24">getedge</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:aeb2da43c411ed0a239798a2a3c883f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">T2 <a class="el" href="class_adjacency___list.html#aeb2da43c411ed0a239798a2a3c883f24" title="T2 getedge(T1 src, T1 dest) ">getedge(T1 src, T1 dest)</a>  <a href="#aeb2da43c411ed0a239798a2a3c883f24">More...</a><br /></td></tr>
<tr class="separator:aeb2da43c411ed0a239798a2a3c883f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4940d2076901a50659ca83894b945218"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a4940d2076901a50659ca83894b945218">edgeexist</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:a4940d2076901a50659ca83894b945218"><td class="mdescLeft">&#160;</td><td class="mdescRight">bool <a class="el" href="class_adjacency___list.html#a4940d2076901a50659ca83894b945218" title="bool edgeexist(T1 src, T1 dest) ">edgeexist(T1 src, T1 dest)</a>  <a href="#a4940d2076901a50659ca83894b945218">More...</a><br /></td></tr>
<tr class="separator:a4940d2076901a50659ca83894b945218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fef72d4ecb4cfa5438a653e1e58e91b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a5fef72d4ecb4cfa5438a653e1e58e91b">vertexexists</a> (T1 node)</td></tr>
<tr class="memdesc:a5fef72d4ecb4cfa5438a653e1e58e91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">bool <a class="el" href="class_adjacency___list.html#a5fef72d4ecb4cfa5438a653e1e58e91b" title="bool vertexexists(T1 node) ">vertexexists(T1 node)</a>  <a href="#a5fef72d4ecb4cfa5438a653e1e58e91b">More...</a><br /></td></tr>
<tr class="separator:a5fef72d4ecb4cfa5438a653e1e58e91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183c55c71c959b90164a334687a76cc2"><td class="memItemLeft" align="right" valign="top">T1&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a183c55c71c959b90164a334687a76cc2">getvertex</a> (T1 node)</td></tr>
<tr class="memdesc:a183c55c71c959b90164a334687a76cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">T1 <a class="el" href="class_adjacency___list.html#a183c55c71c959b90164a334687a76cc2" title="T1 getvertex(T1 node) ">getvertex(T1 node)</a>  <a href="#a183c55c71c959b90164a334687a76cc2">More...</a><br /></td></tr>
<tr class="separator:a183c55c71c959b90164a334687a76cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd4579e85308ada2431895a71c5f7c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a8bd4579e85308ada2431895a71c5f7c7">displaygraph</a> (uint16_t w)</td></tr>
<tr class="memdesc:a8bd4579e85308ada2431895a71c5f7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a8bd4579e85308ada2431895a71c5f7c7" title="void displaygraph(uint16_t w) ">displaygraph(uint16_t w)</a>  <a href="#a8bd4579e85308ada2431895a71c5f7c7">More...</a><br /></td></tr>
<tr class="separator:a8bd4579e85308ada2431895a71c5f7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18dd59802c4a04906aec8cc0703254e8"><td class="memItemLeft" align="right" valign="top">std::deque&lt; T1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a18dd59802c4a04906aec8cc0703254e8">dfs</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:a18dd59802c4a04906aec8cc0703254e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::deque&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a18dd59802c4a04906aec8cc0703254e8" title="std::deque&lt;T1&gt; dfs(T1 src, T1 dest) ">dfs(T1 src, T1 dest)</a>  <a href="#a18dd59802c4a04906aec8cc0703254e8">More...</a><br /></td></tr>
<tr class="separator:a18dd59802c4a04906aec8cc0703254e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c640eaabccc946280cac85aa6f5998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a36c640eaabccc946280cac85aa6f5998">ddfs</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:a36c640eaabccc946280cac85aa6f5998"><td class="mdescLeft">&#160;</td><td class="mdescRight">void ddfs  <a href="#a36c640eaabccc946280cac85aa6f5998">More...</a><br /></td></tr>
<tr class="separator:a36c640eaabccc946280cac85aa6f5998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463a0f885dd38f2d49b928bc12b1cdcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a463a0f885dd38f2d49b928bc12b1cdcc">setdirected</a> (bool isdirected)</td></tr>
<tr class="memdesc:a463a0f885dd38f2d49b928bc12b1cdcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a463a0f885dd38f2d49b928bc12b1cdcc" title="void setdirected(bool isdirected) ">setdirected(bool isdirected)</a>  <a href="#a463a0f885dd38f2d49b928bc12b1cdcc">More...</a><br /></td></tr>
<tr class="separator:a463a0f885dd38f2d49b928bc12b1cdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae736daafd94362c6490babb98babb751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#ae736daafd94362c6490babb98babb751">addedge</a> (T1 src, T1 dest, T2 link)</td></tr>
<tr class="memdesc:ae736daafd94362c6490babb98babb751"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#ae736daafd94362c6490babb98babb751" title="void addedge(T1 src, T1 dest, T2 link) ">addedge(T1 src, T1 dest, T2 link)</a>  <a href="#ae736daafd94362c6490babb98babb751">More...</a><br /></td></tr>
<tr class="separator:ae736daafd94362c6490babb98babb751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12d7868abec7c406ac4f91c1baf8663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#aa12d7868abec7c406ac4f91c1baf8663">addvertex</a> (T1 node)</td></tr>
<tr class="memdesc:aa12d7868abec7c406ac4f91c1baf8663"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#aa12d7868abec7c406ac4f91c1baf8663" title="void addvertex(T1 node) ">addvertex(T1 node)</a>  <a href="#aa12d7868abec7c406ac4f91c1baf8663">More...</a><br /></td></tr>
<tr class="separator:aa12d7868abec7c406ac4f91c1baf8663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472ebd0a5b83448088959d1173fba710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a472ebd0a5b83448088959d1173fba710">removeedge</a> (T1 src, T1 dest)</td></tr>
<tr class="memdesc:a472ebd0a5b83448088959d1173fba710"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a472ebd0a5b83448088959d1173fba710" title="void removeedge(T1 src, T1 dest) ">removeedge(T1 src, T1 dest)</a>  <a href="#a472ebd0a5b83448088959d1173fba710">More...</a><br /></td></tr>
<tr class="separator:a472ebd0a5b83448088959d1173fba710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1794c310f08f59d85cb57b5d33caa667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_adjacency___list.html#a1794c310f08f59d85cb57b5d33caa667">removevertex</a> (T1 node)</td></tr>
<tr class="memdesc:a1794c310f08f59d85cb57b5d33caa667"><td class="mdescLeft">&#160;</td><td class="mdescRight">void <a class="el" href="class_adjacency___list.html#a1794c310f08f59d85cb57b5d33caa667" title="void removevertex(T1 node) ">removevertex(T1 node)</a>  <a href="#a1794c310f08f59d85cb57b5d33caa667">More...</a><br /></td></tr>
<tr class="separator:a1794c310f08f59d85cb57b5d33caa667"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T1, class T2&gt;<br />
class Adjacency_List&lt; T1, T2 &gt;</h3>

<p><a class="el" href="class_adjacency___list.html" title="Adjacency_List class template. This is a template for a graph of vertices and edges of types T1 and T...">Adjacency_List</a> class template. This is a template for a graph of vertices and edges of types T1 and T2, respectively. </p>
<p>.hh </p><dl class="section author"><dt>Author</dt><dd>Andrew French </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jan 8, 2014</dd></dl>
<p>The <a class="el" href="class_adjacency___list.html" title="Adjacency_List class template. This is a template for a graph of vertices and edges of types T1 and T...">Adjacency_List</a> class is a container class that stores information in the form of a graph, either directed or undirected, through locally defined vertices and edges. This class supports dynamic insertion and removal of both vertices and edges, contrary to popular implementations. A basic depth-firsth-algorithm is also included, providing simple path-finding between vertices, so long as the graph is connected. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad2d0ad868f211a253fc7f5fc09f29b65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;T2, <a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a>*&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html#ad2d0ad868f211a253fc7f5fc09f29b65">edge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>edge type definition: </p>
<p>pair of type T2 object and pointer to a vertex </p>

</div>
</div>
<a class="anchor" id="a36f797555285f40b0320eb745774e127"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_adjacency___list_1_1vertex.html">Adjacency_List::vertex</a>  <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html#a36f797555285f40b0320eb745774e127">vertex_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vertex type definition for the <a class="el" href="class_adjacency___list.html" title="Adjacency_List class template. This is a template for a graph of vertices and edges of types T1 and T...">Adjacency_List</a> graph class. </p>
<p>Each vertex of type T1 contains a list of pointers to the vertices adjacent to it, paired with an object of type T2. Each vertex also contains a boolean that is used in the search algorithms. </p>

</div>
</div>
<a class="anchor" id="a5f1ff6746e887afb9fd3eb33f0692e84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;T1, <a class="el" href="struct_adjacency___list_1_1vertex.html">vertex</a>*&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html#a5f1ff6746e887afb9fd3eb33f0692e84">vertexmap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vertexmap type definition: </p>
<p>This is the all encompassing data structure. A pointer to each vertex is stored in a map. A map was chosen for its fast (O(1)) access and (O(log(n))) search methods (i.e. std::find()). </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a730c002bfea9ee4745be4b11e5ca10db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::<a class="el" href="class_adjacency___list.html">Adjacency_List</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Default constructor: creates empty undirected graph. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae736daafd94362c6490babb98babb751"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::addedge </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2&#160;</td>
          <td class="paramname"><em>link</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#ae736daafd94362c6490babb98babb751" title="void addedge(T1 src, T1 dest, T2 link) ">addedge(T1 src, T1 dest, T2 link)</a> </p>
<p>Add edge between two vertices, if both exist. </p>

</div>
</div>
<a class="anchor" id="aa12d7868abec7c406ac4f91c1baf8663"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::addvertex </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#aa12d7868abec7c406ac4f91c1baf8663" title="void addvertex(T1 node) ">addvertex(T1 node)</a> </p>
<p>Add vertex to graph. </p>

</div>
</div>
<a class="anchor" id="a36c640eaabccc946280cac85aa6f5998"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::ddfs </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void ddfs </p>
<p>double ended (2-way) depth-first-search. Not yet implemented.</p>
<p>Advantages: faster searches for large graphs </p>

</div>
</div>
<a class="anchor" id="a18dd59802c4a04906aec8cc0703254e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;T1&gt; <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::dfs </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>std::deque&lt;T1&gt; <a class="el" href="class_adjacency___list.html#a18dd59802c4a04906aec8cc0703254e8" title="std::deque&lt;T1&gt; dfs(T1 src, T1 dest) ">dfs(T1 src, T1 dest)</a> </p>
<p>Wrapper around _dfs (depth-first-search) algorithm that provides a cleaner user interface. See _dfs in the private section to view the algorithm implementation.</p>
<p>This function returns a path between two vertices if one exists. If no path exists, the dq output will be empty, which can be checked externally using dq.empty(). If more than one path exists, there is NO guarantee that the path found will be the shorted path.</p>
<p>Note: std::stack can be used in place of std::deque for less overhead however the deque comes with an iterator. this is an easy fix if needed later on. </p>

</div>
</div>
<a class="anchor" id="a8bd4579e85308ada2431895a71c5f7c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::displaygraph </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a8bd4579e85308ada2431895a71c5f7c7" title="void displaygraph(uint16_t w) ">displaygraph(uint16_t w)</a> </p>
<p>Display graph to console. Parameter w determines setw formatting. Could overload &lt;&lt; operator </p>

</div>
</div>
<a class="anchor" id="a4940d2076901a50659ca83894b945218"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::edgeexist </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bool <a class="el" href="class_adjacency___list.html#a4940d2076901a50659ca83894b945218" title="bool edgeexist(T1 src, T1 dest) ">edgeexist(T1 src, T1 dest)</a> </p>
<p>Determine if an edge exists between two vertices. To prevent runtime errors this should ALWAYS be called before <a class="el" href="class_adjacency___list.html#aeb2da43c411ed0a239798a2a3c883f24" title="T2 getedge(T1 src, T1 dest) ">getedge()</a>. </p>

</div>
</div>
<a class="anchor" id="aeb2da43c411ed0a239798a2a3c883f24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T2 <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::getedge </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>T2 <a class="el" href="class_adjacency___list.html#aeb2da43c411ed0a239798a2a3c883f24" title="T2 getedge(T1 src, T1 dest) ">getedge(T1 src, T1 dest)</a> </p>
<p>Return edge between two vertices, if one exists. </p>

</div>
</div>
<a class="anchor" id="afc9a43d2d171801e35c1f45ae6baca93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::getnumv </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>uint16_t <a class="el" href="class_adjacency___list.html#afc9a43d2d171801e35c1f45ae6baca93" title="uint16_t getnumv() ">getnumv()</a> </p>
<p>Return the number of vertices. </p>

</div>
</div>
<a class="anchor" id="a183c55c71c959b90164a334687a76cc2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T1 <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::getvertex </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>T1 <a class="el" href="class_adjacency___list.html#a183c55c71c959b90164a334687a76cc2" title="T1 getvertex(T1 node) ">getvertex(T1 node)</a> </p>
<p>Return vertex from graph, if it exists </p>

</div>
</div>
<a class="anchor" id="a472ebd0a5b83448088959d1173fba710"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::removeedge </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a472ebd0a5b83448088959d1173fba710" title="void removeedge(T1 src, T1 dest) ">removeedge(T1 src, T1 dest)</a> </p>
<p>Remove edge from graph. </p>

</div>
</div>
<a class="anchor" id="a1794c310f08f59d85cb57b5d33caa667"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::removevertex </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a1794c310f08f59d85cb57b5d33caa667" title="void removevertex(T1 node) ">removevertex(T1 node)</a> </p>
<p>Remove vertex, and all associated edges, from graph. </p>

</div>
</div>
<a class="anchor" id="a463a0f885dd38f2d49b928bc12b1cdcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::setdirected </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isdirected</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>void <a class="el" href="class_adjacency___list.html#a463a0f885dd38f2d49b928bc12b1cdcc" title="void setdirected(bool isdirected) ">setdirected(bool isdirected)</a> </p>
<p>Set the directedness of the graph. Default is undirected (false) </p>

</div>
</div>
<a class="anchor" id="a5fef72d4ecb4cfa5438a653e1e58e91b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_adjacency___list.html">Adjacency_List</a>&lt; T1, T2 &gt;::vertexexists </td>
          <td>(</td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>bool <a class="el" href="class_adjacency___list.html#a5fef72d4ecb4cfa5438a653e1e58e91b" title="bool vertexexists(T1 node) ">vertexexists(T1 node)</a> </p>
<p>Check if vertex is in graph </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="_adjacency___list_8hpp_source.html">Adjacency_List.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
